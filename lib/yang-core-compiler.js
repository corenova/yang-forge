// Generated by CoffeeScript 1.9.1
(function() {
  var MetaClass, YangCoreCompiler,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  MetaClass = require('meta-class');

  YangCoreCompiler = (function(superClass) {
    extend(YangCoreCompiler, superClass);

    function YangCoreCompiler() {
      return YangCoreCompiler.__super__.constructor.apply(this, arguments);
    }

    YangCoreCompiler.set({
      module: {
        resolver: function(arg, params) {
          return (function(superClass1) {
            extend(_Class, superClass1);

            function _Class() {
              return _Class.__super__.constructor.apply(this, arguments);
            }

            return _Class;

          })(this);
        },
        extension: '0..n',
        supplement: '0..n'
      },
      extension: {
        resolver: function(arg, params) {
          this.merge(arg, params);
          return null;
        },
        argument: '0..1',
        description: '0..1',
        reference: '0..1',
        status: '0..1',
        sub: '0..n'
      },
      argument: {
        'yin-element': '0..1'
      },
      description: {
        'argument text': {
          'yin-element': true
        }
      },
      reference: {
        'argument text': {
          'yin-element': true
        }
      },
      status: {
        argument: 'value'
      },
      value: {
        argument: 'value'
      },
      'yang-version': {
        argument: 'value'
      },
      'yin-element': {
        argument: 'value'
      },
      sub: {
        argument: 'extension-name',
        resolver: function(arg, params) {
          return params != null ? params.value : void 0;
        },
        value: '0..1'
      },
      supplement: {
        argument: 'extension-name',
        resolver: function(arg, params) {
          this.merge(arg, params);
          return null;
        },
        sub: '0..n'
      }
    });

    YangCoreCompiler.parser = require('yang-parser');

    YangCoreCompiler.preprocess = function(schema) {
      var extensions, i, j, len, len1, params, ref, ref1, statement, stmt, substmt;
      statement = this.parser.parse(schema);
      if (statement == null) {
        return;
      }
      extensions = {};
      ref = statement.substmts;
      for (i = 0, len = ref.length; i < len; i++) {
        stmt = ref[i];
        if (!(stmt.kw === 'extension')) {
          continue;
        }
        params = {};
        ref1 = stmt.substmts;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          substmt = ref1[j];
          if (substmt.substmts.length === 0) {
            params[substmt.kw] = substmt.arg;
          }
        }
        extensions[stmt.arg] = params;
      }
      return (function(superClass1) {
        extend(_Class, superClass1);

        function _Class() {
          return _Class.__super__.constructor.apply(this, arguments);
        }

        _Class.set(extensions);

        return _Class;

      })(MetaClass);
    };

    YangCoreCompiler.compile = function(schema, meta) {
      var output;
      if (meta == null) {
        meta = {};
      }
      if (schema == null) {
        return;
      }
      if (meta instanceof Function) {
        this.merge(meta);
      }
      output = this.compileStatement(this.parser.parse(schema));
      return output != null ? output.value : void 0;
    };

    YangCoreCompiler.compileStatement = function(statement) {
      var keyword, meta, normalize, params, ref, results, stmt, target, value;
      if (!((statement != null) && statement instanceof Object)) {
        return;
      }
      normalize = function(statement) {
        return ([statement.prf, statement.kw].filter(function(e) {
          return (e != null) && !!e;
        })).join(':');
      };
      keyword = normalize(statement);
      target = this.get(keyword);
      if (target == null) {
        console.log("WARN: unrecognized keyword extension '" + keyword + "', skipping...");
        return null;
      }
      results = (function() {
        var i, len, ref, results1;
        ref = statement.substmts;
        results1 = [];
        for (i = 0, len = ref.length; i < len; i++) {
          stmt = ref[i];
          if ((function() {
            switch (false) {
              case !((meta = this.get(keyword)) == null):
                console.log("WARN: unable to find metadata for " + keyword);
                return false;
              case !!(meta.hasOwnProperty(normalize(stmt))):
                console.log("WARN: " + keyword + " does not have sub-statement declared for " + (normalize(stmt)));
                return false;
              default:
                return true;
            }
          }).call(this)) {
            results1.push(this.compileStatement(stmt));
          }
        }
        return results1;
      }).call(this);
      params = (results.filter(function(e) {
        return (e != null) && (e.value != null);
      })).reduce((function(a, b) {
        a[b.name] = b.value;
        return a;
      }), {});
      value = (function() {
        switch (false) {
          case !(target.resolver instanceof Function):
            return target.resolver.call(this, statement.arg, params, target);
          case !((Object.keys(params)).length > 0):
            return (function(superClass1) {
              extend(_Class, superClass1);

              function _Class() {
                return _Class.__super__.constructor.apply(this, arguments);
              }

              return _Class;

            })(MetaClass);
          default:
            return statement.arg;
        }
      }).call(this);
      if (value != null) {
        if (typeof value.set === "function") {
          value.set({
            yang: keyword
          });
        }
      }
      if (value != null) {
        if (typeof value.extend === "function") {
          value.extend(params);
        }
      }
      if ((statement.arg != null) && value instanceof Function) {
        this.set(statement.kw + ":" + statement.arg, value);
      }
      switch (false) {
        case !((Object.keys(params)).length > 0):
          return {
            name: (ref = statement.arg) != null ? ref : statement.kw,
            value: value
          };
        default:
          return {
            name: statement.kw,
            value: value
          };
      }
    };

    return YangCoreCompiler;

  })(MetaClass);

  module.exports = YangCoreCompiler;

}).call(this);
