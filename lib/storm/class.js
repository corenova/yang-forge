// Generated by CoffeeScript 1.9.1
(function() {
  var StormClass;

  Array.prototype.unique = function() {
    var i, key, output, ref, results, val, value;
    if (!(this.length > 0)) {
      return this;
    }
    output = {};
    for (key = i = 0, ref = this.length - 1; 0 <= ref ? i <= ref : i >= ref; key = 0 <= ref ? ++i : --i) {
      val = this[key];
      switch (false) {
        case !(typeof val === 'object' && (val.id != null)):
          output[val.id] = val;
          break;
        default:
          output[val] = val;
      }
    }
    results = [];
    for (key in output) {
      value = output[key];
      results.push(value);
    }
    return results;
  };

  Array.prototype.contains = function(query) {
    var hit;
    if (typeof query !== "object") {
      return false;
    }
    hit = Object.keys(query).length;
    return this.some(function(item) {
      var key, match, val;
      match = 0;
      for (key in query) {
        val = query[key];
        if (item[key] === val) {
          match += 1;
        }
      }
      if (match === hit) {
        return true;
      } else {
        return false;
      }
    });
  };

  Array.prototype.where = function(query) {
    var hit;
    if (typeof query !== "object") {
      return [];
    }
    hit = Object.keys(query).length;
    return this.filter(function(item) {
      var key, match, val;
      match = 0;
      for (key in query) {
        val = query[key];
        if (item[key] === val) {
          match += 1;
        }
      }
      if (match === hit) {
        return true;
      } else {
        return false;
      }
    });
  };

  Array.prototype.without = function(query) {
    if (typeof query !== "object") {
      return this;
    }
    return this.filter(function(item) {
      var key, val;
      for (key in query) {
        val = query[key];
        if (item[key] !== val) {
          return true;
        }
      }
      return false;
    });
  };

  Array.prototype.pushRecord = function(record) {
    if (typeof record !== "object") {
      return null;
    }
    if (!this.contains({
      id: record.id
    })) {
      return this.push(record);
    }
  };

  StormClass = (function() {
    function StormClass() {}

    StormClass.meta = {
      storm: 'class'
    };

    StormClass.copy = (require('util'))._extend;

    StormClass.set = function(obj) {
      return this.meta = this.copy(this.copy({}, this.meta), obj);
    };

    StormClass.get = function(key) {
      return this.meta[key];
    };

    StormClass.extend = function(obj) {
      var k, v;
      for (k in obj) {
        v = obj[k];
        this[k] = v;
      }
      return this;
    };

    StormClass.include = function(obj) {
      var k, v;
      for (k in obj) {
        v = obj[k];
        this.prototype[k] = v;
      }
      return this;
    };

    StormClass.toJSON = function(type, tag) {
      var k, o, prefix, ref, ref1, t, v;
      if (type == null) {
        type = 'storm';
      }
      if (tag == null) {
        tag = true;
      }
      o = {};
      for (k in this) {
        v = this[k];
        if (!(v instanceof Function) && k !== '__super__' && k !== 'meta') {
          o[k] = v;
        }
      }
      ref = this.prototype;
      for (k in ref) {
        v = ref[k];
        if (!(k !== 'constructor' && (((ref1 = v.meta) != null ? ref1.storm : void 0) != null))) {
          continue;
        }
        if ((v.get(type)) == null) {
          continue;
        }
        prefix = (v.get(type)) + ':';
        o[prefix + k] = typeof v.toJSON === "function" ? v.toJSON(type, false) : void 0;
      }
      if (tag === true) {
        prefix = this.get(type);
        if (this.meta.name != null) {
          prefix += ':' + this.meta.name;
        }
        t = {};
        t[prefix] = o;
        return t;
      } else {
        return o;
      }
    };

    StormClass.prototype.assert = require('assert');

    return StormClass;

  })();

  module.exports = StormClass;

}).call(this);
