# YANG Version 1.0 Extensions
#
# This submodule implements the [RFC 6020](http://www.rfc-editor.org/rfc/rfc6020.txt) 
# compliant language extensions.  It is used by `yangforge` to produce a new compiler
# that can then be used to compile any other v1 compatible YANG schema
# definitions into JS code.
#
# The extensions are handled by utilizing the `data-synth` library
# which provides contextual mapping for different types of extension
# statements to logical JS object representations.
#
# Writing new extensions for YANG language is very straight-forward as
# long as the context for the callback function to handle the
# extension is well understood.  For more details, please refer to
# documentation found inside the main `yangforge` project.

name: yang-v1-extensions
license: MIT
schema: !yang/schema yang-v1-extensions.yang
keywords:
  - yang
  - rfc6020

# 
extension:
  augment: !yang/extension
    anyxml: 0..n
    case: 0..n
    choice: 0..n
    container: 0..n
    description: 0..1
    if-feature: 0..n
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    reference: 0..1
    status: 0..1
    uses: 0..n
    when: 0..1

  belongs-to: !yang/extension
    prefix: 1
    preprocess: !coffee/function |
      (arg, params, ctx) -> @source[params.prefix] = @source

  # TODO
  bit: !yang/extension
    description: 0..1
    reference: 0..1
    status: 0..1
    position: 0..1

  # TODO
  case: !yang/extension
    anyxml: 0..n
    choice: 0..n
    container: 0..n
    description: 0..1
    if-feature: 0..n
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    reference: 0..1
    status: 0..1
    uses: 0..n
    when: 0..1

  # TODO
  choice: !yang/extension
    anyxml: 0..n
    case: 0..n
    config: 0..1
    container: 0..n
    default: 0..1
    description: 0..1
    if-feature: 0..n
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    mandatory: 0..1
    reference: 0..1
    status: 0..1
    when: 0..1

  config: !yang/extension
    preprocess: !coffee/function |
      (arg, p, ctx) -> ctx.config = (arg is 'true')

  container: !yang/extension
    anyxml: 0..n
    choice: 0..n
    config: 0..1
    container: 0..n
    description: 0..1
    grouping: 0..n
    if-feature: 0..n
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    must: 0..n
    presence: 0..1
    reference: 0..1
    status: 0..1
    typedef: 0..n
    uses: 0..n
    when: 0..1
    construct: !coffee/function |
      (arg, params, children) -> (@Synth.Object params).bind children

  # TODO
  deviate: !yang/extension
    config: 0..1
    default: 0..1
    mandatory: 0..1
    max-elements: 0..1
    min-elements: 0..1
    must: 0..n
    type: 0..1
    unique: 0..1
    units: 0..1

  # TODO
  deviation: !yang/extension
    description: 0..1
    deviate: 1..n
    reference: 0..1

  enum: !yang/extension
    description: 0..1
    reference: 0..1
    status: 0..1
    value: 0..1
    preprocess: !coffee/function |
      (arg, params, ctx) ->
        unless params.value?
          @enumValue ?= 0
          params.value = @enumValue++
        else
          params.value = (Number) params.value
          @enumValue = params.value + 1
        ctx.enum[arg] = params

  feature: !yang/extension
    description: 0..1
    if-feature: 0..n
    reference: 0..1
    status: 0..1
    preprocess: !coffee/function |
      (arg, params, ctx) ->
        unless ((v for k, v of params['if-feature']).every (e) -> e is true)
          if typeof ctx.feature is 'object'
            delete ctx.feature[arg]
          else
            delete ctx.feature
    construct: !coffee/function |
      (arg, params, children) ->
        feature = @resolve 'feature', arg
        null

  grouping: !yang/extension
    anyxml: 0..n
    choice: 0..n
    container: 0..n
    description: 0..1
    grouping: 0..n
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    reference: 0..1
    status: 0..1
    typedef: 0..n
    uses: 0..n
    preprocess: !coffee/function |
      (arg, params) -> @define 'grouping', arg, params

  identity: !yang/extension
    base: 0..1
    description: 0..1
    reference: 0..1
    status: 0..1
    # TODO: resolve 'base' statements
    preprocess: !coffee/function |
      (arg, params) -> @define 'identity', arg, params

  if-feature: !yang/extension
    preprocess: !coffee/function |
      (arg, params, ctx) -> 
        unless typeof ctx['if-feature'] is 'object'
          ctx['if-feature'] = {}
        ctx['if-feature'][arg] = (@resolve 'feature', arg)?

  import: !yang/extension
    prefix: 1
    revision-date: 0..1
    preprocess: !coffee/function |
      (arg, params, ctx) -> 
        m = @preprocess (@resolve 'dependencies', arg)
        rev = params['revision-date']
        if rev? and not (rev of m.revision)
          throw @error "[import] requested #{rev} not available in #{arg}", ctx
        @define 'extension', k, v for k, v of m.extension when v.override is true
        @source[params.prefix] = m

  include: !yang/extension
    revision-date: 0..1

  input: !yang/extension
    anyxml: 0..n
    choice: 0..n
    container: 0..n
    grouping: 0..n
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    typedef: 0..n
    uses: 0..n
    construct: !coffee/function |
      (arg, params, children) -> (@Synth.Object params).bind children

  leaf: !yang/extension
    config: 0..1
    default: 0..1
    description: 0..1
    if-feature: 0..n
    mandatory: 0..1
    must: 0..n
    reference: 0..1
    status: 0..1
    type: 0..1
    units: 0..1
    when: 0..1
    construct: !coffee/function |
      (arg, params) -> (@Synth.Property params)

  leaf-list: !yang/extension
    config: 0..1
    description: 0..1
    if-feature: 0..n
    max-elements: 0..1
    min-elements: 0..1
    must: 0..n
    ordered-by: 0..1
    reference: 0..1
    status: 0..1
    type: 0..1
    units: 0..1
    when: 0..1
    construct: !coffee/function |
      (arg, params) -> (@Synth.List params)

  list: !yang/extension
    anyxml: 0..n
    choice: 0..n 
    config: 0..1
    container: 0..n
    description: 0..1
    grouping: 0..n
    if-feature: 0..n
    key: 0..1
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    max-elements: 0..1
    min-elements: 0..1
    must: 0..n
    ordered-by: 0..1
    reference: 0..1
    status: 0..1
    typedef: 0..n
    unique: 0..1
    uses: 0..n
    when: 0..1
    construct: !coffee/function |
      (arg, params, children) -> 
        item = (@Synth.Object null).bind children
        (@Synth.List params).set type: item

  mandatory: !yang/extension
    preprocess: !coffee/function |
      (arg, p, ctx) -> ctx.mandatory = (arg is 'true')

  module: !yang/extension
    anyxml: 0..n
    augment: 0..n
    choice: 0..n
    contact: 0..1
    container: 0..n
    description: 0..1
    deviation: 0..n
    extension: 0..n
    feature: 0..n
    grouping: 0..n
    identity: 0..n
    import: 0..n
    include: 0..n
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    namespace: 0..1
    notification: 0..n
    organization: 0..1
    prefix: 0..1
    reference: 0..1
    revision: 0..n
    rpc: 0..n
    typedef: 0..n
    uses: 0..n
    yang-version: 0..1
    preprocess: !coffee/function |
      (arg, params, ctx) ->
        for target, changes of params.augment
          match = @locate ctx, target
          continue unless match?
          @Synth.copy match, changes
        delete @source[params.prefix]
    construct: !coffee/function |
      (arg, params, children) -> 
        (@Synth.Store params, -> @set name: arg).bind children

  # TODO
  must: !yang/extension
    description: 0..1
    error-app-tag: 0..1
    error-message: 0..1
    reference: 0..1

  # TODO
  notification: !yang/extension
    anyxml: 0..n
    choice: 0..n
    container: 0..n
    description: 0..1
    grouping: 0..n
    if-feature: 0..n
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    reference: 0..1
    status: 0..1
    typedef: 0..n
    uses: 0..n
    preprocess: !coffee/function |
      (arg, params) -> @define 'notification', arg, params

  output: !yang/extension
    anyxml: 0..n
    choice: 0..n
    container: 0..n
    grouping: 0..n
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    typedef: 0..n
    uses: 0..n
    construct: !coffee/function |
      (arg, params, children) -> (@Synth.Object params).bind children

  pattern: !yang/extension
    preprocess: !coffee/function |
      (arg, params, ctx) -> 
        ctx.patterns ?= []
        ctx.patterns.push new RegExp arg

  prefix: !yang/extension
    preprocess: !coffee/function |
      (arg, params, ctx) -> @source[arg] = @source

  refine: !yang/extension
    default: 0..1
    description: 0..1
    reference: 0..1
    config: 0..1
    mandatory: 0..1
    presence: 0..1
    must: 0..n
    min-elements: 0..1
    max-elements: 0..1

  require-instance: !yang/extension
    preprocess: !coffee/function |
      (arg, params, ctx) -> ctx['require-instance'] = (arg is 'true')

  revision: !yang/extension
    description: 0..1
    reference: 0..1
    preprocess: !coffee/function |
      (arg, params, ctx) -> @define 'revision', arg, params

  rpc: !yang/extension
    description: 0..1
    grouping: 0..n
    if-feature: 0..n
    input: 0..1
    output: 0..1
    reference: 0..1
    status: 0..1
    typedef: 0..n
    construct: !coffee/function |
      (arg, params, children) ->
        func = @resolve 'rpc', arg, false
        return unless func instanceof Function
        request  = children.input  ? @Synth.Meta
        response = children.output ? @Synth.Meta
        (data, resolve, reject) ->
          console.log "executing rpc #{arg}..."
          input = new request data
          output = new response
          func.call this, input, output, (e) ->
            unless e? then resolve output else reject e
        
  submodule: !yang/extension
    argument: name
    anyxml: 0..n
    augment: 0..n
    belongs-to: 0..1
    choice: 0..n
    contact: 0..1
    container: 0..n
    description: 0..1
    deviation: 0..n
    extension: 0..n
    feature: 0..n
    grouping: 0..n
    identity: 0..n
    import: 0..n
    include: 0..n
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    notification: 0..n
    organization: 0..1
    reference: 0..1
    revision: 0..n
    rpc: 0..n
    typedef: 0..n
    uses: 0..n
    yang-version: 0..1
    preprocess: !coffee/function |
      (arg, params, ctx) ->
        ctx[k] = v for k, v of params
        delete ctx.submodule

  type: !yang/extension
    base: 0..1
    bit: 0..n
    enum: 0..n
    fraction-digits: 0..1
    length: 0..1
    path: 0..1
    pattern: 0..n
    range: 0..1
    require-instance: 0..1
    type: 0..n # for 'union' case only

    preprocess: !coffee/function |
      (arg, params, ctx) -> delete @enumValue

    construct: !coffee/function |
      (arg, params, children, ctx) ->
        basis = @resolve 'typedef', arg
        ctx.type = class
          constructor: (value) ->
            @name = arg
            value = (basis.normalize? value) ? value
            if basis.validate?
              console.assert (basis.validate? value, params),
                "unable to validate passed-in '#{value}' as '#{arg}'"
            @value = value
          valueOf: -> @value

  typedef: !yang/extension
    default: 0..1
    description: 0..1
    units: 0..1
    type: 0..1
    reference: 0..1
    preprocess: !coffee/function |
      (arg, params) -> @define 'typedef', arg, params

  uses: !yang/extension
    augment: 0..n
    description: 0..1
    if-feature: 0..n
    refine: 0..n
    reference: 0..1
    status: 0..1
    when: 0..1
    preprocess: !coffee/function |
      (arg, params, ctx) ->
        @Synth.copy ctx, (@resolve 'grouping', arg)
        for target, changes of params.refine
          match = @locate ctx, target
          continue unless match?
          match[k] = v for k, v of changes
        for target, changes of params.augment
          match = @locate ctx, target
          continue unless match?
          @Synth.copy match, changes

# YANG v1.0 built-in TYPE DEFINITIONS
typedef:
  int8:
    type: { number: { range: -128..127 } }

  int16: !yang/schema |
    type number {
      range "-32768..32767";
    }

  number:

  enumeration:
    normalize: !coffee/function |
      (value) -> 
        if typeof value is 'number'
          for key, val of @enum when val.value is value or val.value is "#{value}"
            return key
        value
    validate: !coffee/function |
      (value) -> @enum.hasOwnProperty value

  string:
    normalize: !coffee/function |
      (value) -> "#{value}"
    validate: !coffee/function |
      (value, opts) ->
        tests = [ (v) -> typeof v is 'string' ]
        if opts.patterns?
          tests.push (v) -> opts.patterns.every (regex) -> regex.test v
        if opts.length?
          tests.push (v) ->
            checks = opts.length.split '|'
            checks.some (cond) -> 
              [ x, y ] = cond.split '..'
              if y? and y isnt 'max'
                (Number) x <= v.length <= (Number) y
              else
                v.length >= (Number) x
        tests.every (test) -> test? value
