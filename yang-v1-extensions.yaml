# YANG Version 1.0 Extensions
#
# This submodule implements the [RFC 6020](http://www.rfc-editor.org/rfc/rfc6020.txt) 
# compliant language extensions.  It is used by `yangforge` to produce a new compiler
# that can then be used to compile any other v1 compatible YANG schema
# definitions into JS code.
#
# The extensions are handled by utilizing the `data-synth` library
# which provides contextual mapping for different types of extension
# statements to logical JS object representations.
#
# Writing new extensions for YANG language is very straight-forward as
# long as the context for the callback function to handle the
# extension is well understood.  For more details, please refer to
# documentation found inside the main `yangforge` project.

name: yang-v1-extensions
license: MIT
schema: !yang/schema yang-v1-extensions.yang
keywords:
  - yang
  - rfc6020

# 
extension:
  augment: !yang/extension
    anyxml:      0..n
    case:        0..n
    choice:      0..n
    container:   0..n
    description: 0..1
    if-feature:  0..n
    leaf:        0..n
    leaf-list:   0..n
    list:        0..n
    reference:   0..1
    status:      0..1
    uses:        0..n
    when:        0..1

  belongs-to: !yang/extension
    prefix: 1
    preprocess: !coffee/function |
      (arg, params, ctx) -> @source[params.prefix] = @source

  # TODO
  bit: !yang/extension
    description: 0..1
    reference: 0..1
    status: 0..1
    position: 0..1

  # TODO
  case: !yang/extension
    anyxml: 0..n
    choice: 0..n
    container: 0..n
    description: 0..1
    if-feature: 0..n
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    reference: 0..1
    status: 0..1
    uses: 0..n
    when: 0..1

  # TODO
  choice: !yang/extension
    anyxml: 0..n
    case: 0..n
    config: 0..1
    container: 0..n
    default: 0..1
    description: 0..1
    if-feature: 0..n
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    mandatory: 0..1
    reference: 0..1
    status: 0..1
    when: 0..1

  config: !yang/extension
    preprocess: !coffee/function |
      (arg, p, ctx) -> ctx.config = (arg is 'true')

  container: !yang/extension
    anyxml: 0..n
    choice: 0..n
    config: 0..1
    container: 0..n
    description: 0..1
    grouping: 0..n
    if-feature: 0..n
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    must: 0..n
    presence: 0..1
    reference: 0..1
    status: 0..1
    typedef: 0..n
    uses: 0..n
    when: 0..1
    construct: !coffee/function |
      (arg, params, children) -> 
        synth = @require 'data-synth'
        (synth.Object params).bind children

  # TODO
  deviate: !yang/extension
    config: 0..1
    default: 0..1
    mandatory: 0..1
    max-elements: 0..1
    min-elements: 0..1
    must: 0..n
    type: 0..1
    unique: 0..1
    units: 0..1

  # TODO
  deviation: !yang/extension
    description: 0..1
    deviate: 1..n
    reference: 0..1

  enum: !yang/extension
    description: 0..1
    reference: 0..1
    status: 0..1
    value: 0..1
    preprocess: !coffee/function |
      (arg, params, ctx) ->
        unless params.value?
          @enumValue ?= 0
          params.value = @enumValue++
        else
          params.value = (Number) params.value
          @enumValue = params.value + 1
        ctx.enum[arg] = params

  feature: !yang/extension
    description: 0..1
    if-feature: 0..n
    reference: 0..1
    status: 0..1
    preprocess: !coffee/function |
      (arg, params, ctx) ->
        unless ((v for k, v of params['if-feature']).every (e) -> e is true)
          if typeof ctx.feature is 'object'
            delete ctx.feature[arg]
          else
            delete ctx.feature
    construct: !coffee/function |
      (arg, params, children) ->
        feature = @resolve 'feature', arg
        null

  grouping: !yang/extension
    anyxml: 0..n
    choice: 0..n
    container: 0..n
    description: 0..1
    grouping: 0..n
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    reference: 0..1
    status: 0..1
    typedef: 0..n
    uses: 0..n
    preprocess: !coffee/function |
      (arg, params) -> @define 'grouping', arg, params

  identity: !yang/extension
    base: 0..1
    description: 0..1
    reference: 0..1
    status: 0..1
    # TODO: resolve 'base' statements
    preprocess: !coffee/function |
      (arg, params) -> @define 'identity', arg, params

  if-feature: !yang/extension
    preprocess: !coffee/function |
      (arg, params, ctx) -> 
        unless typeof ctx['if-feature'] is 'object'
          ctx['if-feature'] = {}
        ctx['if-feature'][arg] = (@resolve 'feature', arg)?

  import: !yang/extension
    prefix: 1
    revision-date: 0..1
    preprocess: !coffee/function |
      (arg, params, ctx) ->
        synth = @require 'data-synth'
        m  = @preprocess (@resolve 'dependencies', arg)
        m ?= @preprocess "!yang/schema #{arg}.yang", @source
        unless m?
          throw @error "unable to resolve '#{arg}' in dependencies", 'import'
        rev = params['revision-date']
        if rev? and not (rev of m.revision)
          throw @error "requested #{rev} not available in #{arg}", 'import'
        for k, v of m.extension when v.override is true
          # we make a copy of v because we don't want importers of
          # THIS module to ALSO override when importing this module
          copy = synth.copy {}, v
          delete copy.override
          @define 'extension', k, copy
        @source[params.prefix] = m

  include: !yang/extension
    revision-date: 0..1

  input: !yang/extension
    anyxml: 0..n
    choice: 0..n
    container: 0..n
    grouping: 0..n
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    typedef: 0..n
    uses: 0..n
    construct: !coffee/function |
      (arg, params, children) -> 
        synth = @require 'data-synth'
        (synth.Object params).bind children

  leaf: !yang/extension
    config: 0..1
    default: 0..1
    description: 0..1
    if-feature: 0..n
    mandatory: 0..1
    must: 0..n
    reference: 0..1
    status: 0..1
    type: 0..1
    units: 0..1
    when: 0..1
    construct: !coffee/function |
      (arg, params, children) -> 
        synth = @require 'data-synth'
        synth.Property params, -> @set type: children.type if children.type?

  leaf-list: !yang/extension
    config: 0..1
    description: 0..1
    if-feature: 0..n
    max-elements: 0..1
    min-elements: 0..1
    must: 0..n
    ordered-by: 0..1
    reference: 0..1
    status: 0..1
    type: 0..1
    units: 0..1
    when: 0..1
    construct: !coffee/function |
      (arg, params) -> 
        synth = @require 'data-synth'
        synth.List params

  list: !yang/extension
    anyxml: 0..n
    choice: 0..n 
    config: 0..1
    container: 0..n
    description: 0..1
    grouping: 0..n
    if-feature: 0..n
    key: 0..1
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    max-elements: 0..1
    min-elements: 0..1
    must: 0..n
    ordered-by: 0..1
    reference: 0..1
    status: 0..1
    typedef: 0..n
    unique: 0..1
    uses: 0..n
    when: 0..1
    construct: !coffee/function |
      (arg, params, children) -> 
        synth = @require 'data-synth'
        item = (synth.Object null).bind children
        (synth.List params).set type: item

  mandatory: !yang/extension
    preprocess: !coffee/function |
      (arg, p, ctx) -> ctx.mandatory = (arg is 'true')

  module: !yang/extension
    anyxml: 0..n
    augment: 0..n
    choice: 0..n
    contact: 0..1
    container: 0..n
    description: 0..1
    deviation: 0..n
    extension: 0..n
    feature: 0..n
    grouping: 0..n
    identity: 0..n
    import: 0..n
    include: 0..n
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    namespace: 0..1
    notification: 0..n
    organization: 0..1
    prefix: 0..1
    reference: 0..1
    revision: 0..n
    rpc: 0..n
    typedef: 0..n
    uses: 0..n
    yang-version: 0..1
    preprocess: !coffee/function |
      (arg, params, ctx) ->
        synth = @require 'data-synth'
        for target, changes of params.augment
          match = @locate ctx, target
          continue unless match?
          synth.copy match, changes
        delete @source[params.prefix]
    construct: !coffee/function |
      (arg, params, children) -> 
        synth = @require 'data-synth'
        (synth.Model params, -> @set name: arg).bind children

  # TODO
  must: !yang/extension
    description: 0..1
    error-app-tag: 0..1
    error-message: 0..1
    reference: 0..1

  # TODO
  notification: !yang/extension
    anyxml: 0..n
    choice: 0..n
    container: 0..n
    description: 0..1
    grouping: 0..n
    if-feature: 0..n
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    reference: 0..1
    status: 0..1
    typedef: 0..n
    uses: 0..n
    preprocess: !coffee/function |
      (arg, params) -> @define 'notification', arg, params

  output: !yang/extension
    anyxml: 0..n
    choice: 0..n
    container: 0..n
    grouping: 0..n
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    typedef: 0..n
    uses: 0..n
    construct: !coffee/function |
      (arg, params, children) ->
        synth = @require 'data-synth'
        (synth.Object params).bind children

  pattern: !yang/extension
    construct: !coffee/function |
      (arg, params, children, ctx) -> 
        ctx.patterns ?= []
        ctx.patterns.push new RegExp arg

  prefix: !yang/extension
    preprocess: !coffee/function |
      (arg, params, ctx) -> @source[arg] = @source

  refine: !yang/extension
    default: 0..1
    description: 0..1
    reference: 0..1
    config: 0..1
    mandatory: 0..1
    presence: 0..1
    must: 0..n
    min-elements: 0..1
    max-elements: 0..1
    units: 0..1

  require-instance: !yang/extension
    preprocess: !coffee/function |
      (arg, params, ctx) -> ctx['require-instance'] = (arg is 'true')

  revision: !yang/extension
    description: 0..1
    reference: 0..1
    preprocess: !coffee/function |
      (arg, params, ctx) -> @define 'revision', arg, params

  rpc: !yang/extension
    description: 0..1
    grouping: 0..n
    if-feature: 0..n
    input: 0..1
    output: 0..1
    reference: 0..1
    status: 0..1
    typedef: 0..n
    construct: !coffee/function |
      (arg, params, children) ->
        synth = @require 'data-synth'
        func = @resolve 'rpc', arg, false
        return unless func instanceof Function
        request  = children.input  ? synth.Meta
        response = children.output ? synth.Meta
        (data, resolve, reject) ->
          console.log "executing rpc #{arg}..."
          input = new request data
          output = new response
          func.call this, input, output, (e) ->
            unless e? then resolve output else reject e
        
  submodule: !yang/extension
    argument: name
    anyxml: 0..n
    augment: 0..n
    belongs-to: 0..1
    choice: 0..n
    contact: 0..1
    container: 0..n
    description: 0..1
    deviation: 0..n
    extension: 0..n
    feature: 0..n
    grouping: 0..n
    identity: 0..n
    import: 0..n
    include: 0..n
    leaf: 0..n
    leaf-list: 0..n
    list: 0..n
    notification: 0..n
    organization: 0..1
    reference: 0..1
    revision: 0..n
    rpc: 0..n
    typedef: 0..n
    uses: 0..n
    yang-version: 0..1
    preprocess: !coffee/function |
      (arg, params, ctx) ->
        ctx[k] = v for k, v of params
        delete ctx.submodule

  type: !yang/extension
    base: 0..1
    bit: 0..n
    enum: 0..n
    fraction-digits: 0..1
    length: 0..1
    path: 0..1
    pattern: 0..n
    range: 0..1
    require-instance: 0..1
    type: 0..n # for 'union' case only

    preprocess: !coffee/function |
      (arg, params, ctx) -> delete @enumValue

    construct: !coffee/function |
      (arg, params, children, ctx) ->
        synth = @require 'data-synth'
        basis = @resolve 'typedef', arg
        return unless basis?
        for own key, value of basis.type
          basis = @resolve 'typedef', key
          params = value
          break;
        options = synth.copy {}, params
        options.patterns = []
        options.patterns.push new RegExp params.pattern if params.pattern?
        ctx.type = class
          @type = arg
          @valueOf  = -> @type
          @toString = -> @type
          constructor: (value) ->
            @name = arg
            value = (basis.normalize? value, options) ? value
            if basis.validate?
              #console.log "VALIDATE: #{arg}"
              console.assert (basis.validate? value, options),
                "unable to validate passed-in '#{value}' as '#{arg}'"
            @value = value
          get:      -> @value
          valueOf:  -> @value
          toString: -> @constructor.type
        null

  typedef: !yang/extension
    default: 0..1
    description: 0..1
    units: 0..1
    type: 0..1
    reference: 0..1
    preprocess: !coffee/function |
      (arg, params) -> @define 'typedef', arg, params

  uses: !yang/extension
    augment: 0..n
    description: 0..1
    if-feature: 0..n
    refine: 0..n
    reference: 0..1
    status: 0..1
    when: 0..1
    preprocess: !coffee/function |
      (arg, params, ctx) ->
        synth = @require 'data-synth'
        synth.copy ctx, (@resolve 'grouping', arg)
        for target, changes of params.refine
          match = @locate ctx, target
          continue unless match?
          match[k] = v for k, v of changes
        for target, changes of params.augment
          match = @locate ctx, target
          continue unless match?
          synth.copy match, changes

# YANG v1.0 built-in TYPE DEFINITIONS
typedef:
  int8:
    type: { number: { range: -128..127 } }

  int16: !yang/schema |
    type number {
      range "-32768..32767";
    }

  number:

  enumeration:
    normalize: !coffee/function |
      (value, opts) -> 
        if typeof value is 'number'
          for key, val of opts.enum when val.value is value or val.value is "#{value}"
            return key
        value
    validate: !coffee/function |
      (value, opts) -> opts.enum.hasOwnProperty value

  # boolean:
  #   normalize: !coffee/function |
  #     (value) -> 
  #       console.log "normalizing boolean!"
  #       unless typeof value is 'boolean' then value is 'true' else value
  #   validate: !coffee/function |
  #     (value) -> typeof value is 'boolean'

  string:
    normalize: !coffee/function |
      (value) -> "#{value}"
    validate: !coffee/function |
      (value, opts) ->
        tests = [ (v) -> typeof v is 'string' ]
        if opts.patterns?
          tests.push (v) -> opts.patterns.every (regex) -> regex.test v
        if opts.length?
          tests.push (v) ->
            checks = opts.length.split '|'
            checks.some (cond) -> 
              [ x, y ] = cond.split '..'
              if y? and y isnt 'max'
                (Number) x <= v.length <= (Number) y
              else
                v.length >= (Number) x
        tests.every (test) -> test? value
