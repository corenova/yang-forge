// Generated by CoffeeScript 1.9.1
(function() {
  var MetaCompiler, compiler, output,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  MetaCompiler = require('./yang-meta-compiler');

  compiler = new MetaCompiler({
    map: {
      'yang-v1-extensions': '../yang-v1-extensions.yang'
    },
    resolvers: {
      module: function(self) {
        return self;
      },
      submodule: function(self) {
        return self.extend({
          collapse: true
        });
      },
      feature: function(self, arg, params) {
        return this.set("exports.feature." + arg, params);
      },
      identity: function(self, arg, params) {
        return this.set("exports.identity." + arg, params);
      },
      typedef: function(self, arg, params) {
        return this.set("exports.typedef." + arg, params);
      },
      revision: function(self, arg, params) {
        return this.set("exports.revision." + arg, params);
      },
      type: function(self) {
        return self;
      },
      container: function(self) {
        return self;
      },
      "enum": function(self) {
        return self;
      },
      leaf: function(self) {
        return self;
      },
      'leaf-list': function(self) {
        return self;
      },
      list: function(self, arg, params) {
        var children;
        children = (self.get('children')).filter(function(e) {
          return !(self["instanceof"](e));
        });
        self.reduce((function(_this) {
          return function() {
            return _this.assembler.apply(_this, arguments);
          };
        })(this));
        return (function(superClass) {
          extend(_Class, superClass);

          function _Class() {
            return _Class.__super__.constructor.apply(this, arguments);
          }

          _Class.set({
            yang: 'list',
            name: arg,
            model: self,
            children: children
          });

          return _Class;

        })(require('meta-class'));
      },
      rpc: function(self) {
        return self.extend({
          action: true
        });
      },
      input: function(self) {
        return self;
      },
      output: function(self) {
        return self;
      },
      notification: function(self) {
        return self.extend({
          action: true
        });
      },
      'belongs-to': function(self, arg, params) {
        return this.set("" + params.prefix, this.get("modules." + arg));
      },
      uses: function(self, arg) {
        return this.get("exports.grouping." + arg);
      },
      grouping: function(self, arg, params) {
        self.extend({
          collapse: true
        });
        return this.set("exports.grouping." + arg, self);
      },
      augment: function(self, arg, params) {
        var ref;
        if ((ref = this[arg]) != null) {
          if (typeof ref.extend === "function") {
            ref.extend(params);
          }
        }
        return void 0;
      },
      refine: function(self, arg, params) {
        var ref;
        if ((ref = this[arg]) != null) {
          if (typeof ref.extend === "function") {
            ref.extend(params);
          }
        }
        return void 0;
      }
    }
  });

  output = compiler.compile(function() {
    var file, path;
    path = require('path');
    file = path.resolve(__dirname, '../yang-compiler.yang');
    return (require('fs')).readFileSync(file, 'utf-8');
  });

  output.configure(function() {
    var Meta, fs, path, readLocalFile;
    this.mixin(MetaCompiler);
    Meta = require('meta-class');
    this.include({
      generate: function(input) {
        var actors, e, func, map, meta, name, obj, type;
        if (input instanceof Function) {
          input = input.call(this);
        }
        obj = (function() {
          switch (false) {
            case typeof input !== 'string':
              try {
                return JSON.parse(input);
              } catch (_error) {

              }
              break;
            case !(input instanceof Object):
              return input;
          }
        })();
        assert(obj instanceof Object, "cannot generate using invalid input data");
        if (Meta["instanceof"](obj)) {
          return obj;
        }
        meta = (function(superClass) {
          extend(_Class, superClass);

          function _Class() {
            return _Class.__super__.constructor.apply(this, arguments);
          }

          _Class.merge(obj);

          return _Class;

        })(Meta);
        assert(typeof (meta.get('schema')) === 'string', "missing text schema to use for generate");
        actors = meta.extract('resolvers', 'importers', 'handlers');
        for (type in actors) {
          map = actors[type];
          if (!(map instanceof Object)) {
            continue;
          }
          for (name in map) {
            func = map[name];
            if (func instanceof Function) {
              continue;
            }
            try {
              map[name] = eval("(" + func + ")");
            } catch (_error) {
              e = _error;
              delete map[name];
            }
            if (!(map[name] instanceof Function)) {
              delete map[name];
            }
          }
        }
        return this.fork(function() {
          this.set({
            map: meta.get('map'),
            version: meta.get('version')
          });
          this.set(actors);
          return this.compile(meta.get('schema'));
        });
      }
    });
    path = require('path');
    fs = require('fs');
    readLocalFile = function(filename) {
      var file, ref;
      file = path.resolve(path.dirname((ref = module.parent) != null ? ref.filename : void 0), filename);
      return fs.readFileSync(file, 'utf-8');
    };
    this.set({
      importers: {
        '^meta:.*\.json$': function(input) {
          return readLocalFile(input.file);
        },
        '^schema:.*\.yang$': function(input) {
          input.schema = readLocalFile(input.file);
          return input;
        },
        '^module:': function(input) {
          return require(input.file);
        }
      }
    });
    this.include({
      "import": function(input) {
        var e, exists, importer, importers, k, payload, ref, ref1, ref2, regex, v;
        assert(input instanceof Object, "cannot call import without proper input object");
        exists = (function() {
          switch (false) {
            case !Meta["instanceof"](input):
              return input;
            case !Meta["instanceof"](input.source):
              return input.source;
            case !Meta["instanceof"](this.get("modules." + input.name)):
              return this.get("modules." + input.name);
          }
        }).call(this);
        if (exists != null) {
          this.set("modules." + (exists.get('name')), exists);
          return exists;
        }
        if (input.source == null) {
          input.source = this.get("map." + input.name);
        }
        assert(typeof input.source === 'string' && !!input.source, "unable to initiate import without a valid source parameter");
        if (input.file == null) {
          input.file = input.source.replace(/^.*:/, '');
        }
        importers = (ref = this.get('importers')) != null ? ref : {};
        ref1 = this.constructor.get('importers');
        for (k in ref1) {
          v = ref1[k];
          if (importers[k] == null) {
            importers[k] = v;
          }
        }
        this.set("importers", importers);
        ref2 = this.get('importers');
        for (regex in ref2) {
          importer = ref2[regex];
          if (!((new RegExp(regex)).test(input.source))) {
            continue;
          }
          try {
            payload = importer.call(this, input);
          } catch (_error) {
            e = _error;
            console.log(e);
            continue;
          }
          if (payload != null) {
            break;
          }
        }
        assert(payload != null, "unable to import requested module using '" + input.source + "'");
        output = this.generate(payload);
        if (output != null) {
          this.set("modules." + (output.get('name')), output);
        }
        return output;
      }
    });
    (this.get('extensions.import')).refine({
      resolver: function(self, arg, params) {
        var mod;
        mod = this["import"]({
          name: arg
        });
        if (params.prefix == null) {
          params.prefix = mod != null ? mod.prefix : void 0;
        }
        this.set("" + params.prefix, mod.extract('exports', 'extensions'));
        return void 0;
      }
    });
    (this.get('bindings.rpc.import')).configure(function() {
      return this.include({
        exec: function(input) {
          return this["import"](input);
        }
      });
    });
    return this.include({
      "export": function(input) {
        var format, i, key, len, m, obj, ref, ref1, ref2, tosource;
        assert(input instanceof Object, "invalid input to export module");
        assert(typeof input.name === 'string' && !!input.name, "need to pass in 'name' of the module to export");
        format = (ref = input.format) != null ? ref : 'json';
        m = (function() {
          switch (false) {
            case !(Meta["instanceof"](input)):
              return input;
            default:
              return this.get("modules." + input.name);
          }
        }).call(this);
        assert(Meta["instanceof"](m), "unable to retrieve requested module " + input.name + " for export");
        tosource = require('tosource');
        obj = m.extract('name', 'schema', 'map', 'resolvers', 'importers', 'handlers');
        ref1 = ['resolvers', 'importers', 'handlers'];
        for (i = 0, len = ref1.length; i < len; i++) {
          key = ref1[i];
          if ((ref2 = obj[key]) != null) {
            ref2.toJSON = function() {
              var k, v;
              for (k in this) {
                v = this[k];
                if (k !== 'toJSON' && v instanceof Function) {
                  this[k] = tosource(v);
                }
              }
              return this;
            };
          }
        }
        switch (format) {
          case 'json':
            return JSON.stringify(obj);
        }
      }
    });
  });

  module.exports = output;

}).call(this);
