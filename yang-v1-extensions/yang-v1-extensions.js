// Generated by CoffeeScript 1.9.1

/*
YANG Version 1.0 Extensions

This submodule implements the [RFC
6020](http://www.rfc-editor.org/rfc/rfc6020.txt) compliant language
extensions.  It is used by `yangforge` to produce a new compiler that
can then be used to compile any other v1 compatible YANG schema
definitions into JS code.

The extensions are handled by utilizing the `data-synth` library which
provides contextual mapping for different types of extension
statements to logical JS object representations.

Writing new extensions for YANG language is very straight-forward as
long as the context for the callback function to handle the extension
is well understood.  For more details, please refer to documentation
found inside the main `yangforge` project.
 */

(function() {
  var forge;

  forge = require('yangforge');

  module.exports = forge(module, {
    before: function() {
      var DS;
      DS = require('data-synth');
      this.extension('module', function(key, value) {
        return this.bind(key, DS.Module.extend(value));
      });
      this.extension('container', function(key, value) {
        return this.bind(key, DS.Object.extend(value));
      });
      this.extension('enum', function(key, value) {
        return this.bind(key, DS.Enumeration.extend(value));
      });
      this.extension('leaf', function(key, value) {
        return this.bind(key, DS.Property.extend(value));
      });
      this.extension('leaf-list', function(key, value) {
        return this.bind(key, DS.List.extend(value));
      });
      this.extension('list', function(key, value) {
        var entry;
        entry = DS.Object.extend(function() {
          return this.merge(value.extract('bindings'));
        });
        return this.bind(key, (DS.List.extend(value.unbind())).set({
          type: entry
        }));
      });
      this.extension('grouping', function(key, value) {
        return this.compiler.define('grouping', key, value);
      });
      this.extension('typedef', function(key, value) {
        return this.compiler.define('type', key, value);
      });
      this.extension('uses', function(key, value) {
        var ref;
        return this.mixin(((ref = this.compiler.resolve('grouping', key)) != null ? ref : DS.Meta).extend(value));
      });
      this.extension('augment', function(key, value) {
        return this.merge(value);
      });
      this.extension('refine', function(key, value) {
        return this.merge(value);
      });
      this.extension('type', function(key, value) {
        return this.set('type', this.compiler.resolve('type', key));
      });
      this.extension('rpc', function(key, value) {
        this.set("methods." + key, value);
        return this.bind(key, this.compiler.get("procedures." + key));
      });
      this.extension('input', function(key, value) {
        return this.bind('input', value);
      });
      this.extension('output', function(key, value) {
        return this.bind('output', value);
      });
      this.extension('notification', function(key, value) {
        return this.compiler.define('notification', key, value);
      });
      this.extension('belongs-to', function(key, value) {
        return this.compiler.define('module', value.get('prefix'), this.compiler.resolve('module', key));
      });
      return this.extension('import', function(key, value) {
        var mod, prefix, ref;
        mod = this.compiler["import"]({
          name: key
        });
        prefix = (ref = value.get('prefix')) != null ? ref : mod.get('prefix');
        return this.compiler.define('module', prefix, mod);
      });
    }
  });

}).call(this);
