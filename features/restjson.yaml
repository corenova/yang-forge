# REST/JSON interface feature module
#
# This feature add-on module enables dynamic REST/JSON interface
# generation based on available runtime `module` instances.
#
# It utilizes the underlying [express](express.litcoffee) feature add-on
# to dynamically create routing middleware and associates various HTTP
# method facilities according to the available runtime `module`
# instances.

name: restjson
description: REST/JSON web services interface generator

# TODO - componentize various routers
routers:
  source: !coffee/function |
    (router) ->
      (->
        @route '/'
        .all (req, res, next) ->
          if (req.target.meta 'synth') is 'source'
            console.log "Source: #{req.originalUrl}"
            next()
          else next 'route'
        .options (req, res, next) ->
          res.send
            REPORT:
              description: 'get detailed information about this module'
            GET:
              description: 'get serialized output for this module'
            PUT:
              description: 'update configuration for this module'
            COPY:
              description: 'get a copy of this module for cloning it elsewhere'
        .report (req, res, next) -> res.locals.result = req.target.report?(); next()
        return this
      ).call router
  
run: !coffee/function |
  (model, options) ->
    console.log "generating REST/JSON interface..."
    express = model.parent.require 'express'
    synth   = model.parent.require 'data-synth'

    router = (->
      @all '*', (req, res, next) ->
        req.target ?= model.parent
        next()

      @param 'target', (req, res, next, target) ->
        match = req.target.access? target
        if match? then req.target = match; next() else next 'route'

      @get '/', (req, res, next) ->
        res.locals.result = req.target.serialize()
        next()

      return this
    ).call express.Router()

    #Source routing endpoint

    console.log "generating Source Router..."
    sourceRouter = (->
      @route '/'
      .all (req, res, next) ->
        if (req.target.meta 'synth') is 'source'
          console.log "Source: #{req.originalUrl}"
          next()
        else next 'route'
      .options (req, res, next) ->
        res.send
          REPORT:
            description: 'get detailed information about this module'
          GET:
            description: 'get serialized output for this module'
          PUT:
            description: 'update configuration for this module'
          COPY:
            description: 'get a copy of this module for cloning it elsewhere'
      .report (req, res, next) -> res.locals.result = req.target.report?(); next()
      return this
    ).call express.Router()

    #Store routing endpoint

    console.log "generating Store Router..."
    storeRouter = (->
      @route '/'
      .all (req, res, next) ->
        if (req.target.meta 'synth') is 'store'
          console.log "Store: #{req.originalUrl}"
          next()
        else next 'route'
      .report (req, res, next) -> 
        res.locals.result = req.target.parent.info()
        next()

      return this
    ).call express.Router()

    #Model routing endpoint

    console.log "generating Model Router..."
    modelRouter = (->
      @route '/'
      .all (req, res, next) ->
        if (req.target.meta 'synth') in [ 'store', 'model' ]
          console.log "Store: #{req.originalUrl}"
          next()
        else next 'route'
      .put (req, res, next) ->
        (req.target.set req.body).save()
        .then (result) ->
          res.locals.result = req.target.serialize();
          next()
        .catch (err) ->
          req.target.rollback()
          next err

      @param 'action', (req, res, next, action) ->
        if req.target.methods?[action]? then next() else next 'route'

      @route '/:action'
      .options (req, res, next) ->
        meta = req.target.meta "rpc.#{req.params.action}"
        rpc = synth.extract.call meta, 'description', 'status', 'reference', 'input', 'output'
        delete rpc.input?.uses
        delete rpc.input?.typedef
        delete rpc.output?.uses
        delete rpc.output?.typedef
        res.send
          POST: rpc
      .post (req, res, next) ->
        console.info "restjson: invoking rpc operation '#{req.params.action}'".grey
        req.target.invoke req.params.action, req.body
          .then  (output) -> res.locals.result = output.get(); next()
          .catch (err) -> next err
      return this
    ).call express.Router()

    #Object Container processing routing endpoint

    console.log "generating Object Router..."
    objRouter = (->
      @route '/'
      .all (req, res, next) ->
        if (req.target.meta 'synth') is 'object'
          console.log "Object: #{req.originalUrl}"
          next()
        else next 'route'

      # Add any special logic for handling 'container' here

      return this
    ).call express.Router()

    #List Collection processing routing endpoint

    console.log "generating List Router..."
    listRouter = (->
      @route '/'
      .all (req, res, next) ->
        if (req.target.meta 'synth') is 'list'
          console.log "List: #{req.originalUrl}"
          next()
        else next 'route'
      .post (req, res, next) ->
        next "cannot add a new entry without data" unless req.body?
        req.target.push req.body

        model = req.target.seek synth: 'model'
        model.save()
        .then (result) ->
          res.locals.result = req.target.serialize()
          next()
        .catch (err) ->
          model.rollback()
          next err

      @get '/:key', (req, res, next) ->
        res.locals.result = req.target.get req.params.key
        next()

      @delete '/:key', (req, res, next) ->
        req.target.remove req.params.key
        req.target.parent.save()
        .then (result) ->
          res.locals.result = result.serialize()
          next()
        .catch (err) ->
          req.target.parent.rollback()
          next err

      return this
    ).call express.Router()

    #Main REST/JSON routing endpoint

    router.use sourceRouter, storeRouter, modelRouter, objRouter, listRouter
    # Nested Loopback to itself if additional target in the URL
    router.use '/:target', router

    bp = model.parent.require 'body-parser'
    passport = model.parent.require 'passport'
    restjson = (->
      @use bp.urlencoded(extended:true), bp.json(strict:true), passport.initialize()

      @use router, (req, res, next) ->
        # always send back contents of 'result' if available
        unless res.locals.result? then return next 'route'
        res.setHeader 'Expires','-1'
        res.send res.locals.result
        next()

      # default log successful transaction
      @use (req, res, next) ->
        #req.forge.log?.info query:req.params.id,result:res.locals.result,
        # 'METHOD results for %s', req.record?.name
        next()

      # default 'catch-all' error handler
      @use (err, req, res, next) ->
        console.error err
        res.status(500).send error: switch
          when err instanceof Error then err.toString()
          else JSON.stringify err

      return this
    ).call express.Router()

    if options.express?
      console.info "restjson: binding forgery to /restjson".grey
      options.express.use "/restjson", restjson

    return restjson
