// Generated by CoffeeScript 1.9.1
(function() {
  var EventEmitter, StormRegistry, StormRegistryData,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  EventEmitter = require('events').EventEmitter;

  StormRegistryData = (function(superClass) {
    var validate;

    extend(StormRegistryData, superClass);

    function StormRegistryData() {
      return StormRegistryData.__super__.constructor.apply(this, arguments);
    }

    validate = require('json-schema').validate;

    StormRegistryData.prototype.validate = function() {
      var res;
      if (!((this.data != null) && (this.schema != null))) {
        return true;
      }
      res = validate(this.data, this.schema);
      return res.valid;
    };

    StormRegistryData.prototype.serialize = function() {
      return JSON.stringify(this.data);
    };

    return StormRegistryData;

  })(EventEmitter);

  StormRegistry = (function(superClass) {
    var async, bunyan, uuid;

    extend(StormRegistry, superClass);

    uuid = require('node-uuid');

    async = require('async');

    bunyan = require('bunyan');

    function StormRegistry(opts) {
      var filename, ref;
      if ((opts != null) && opts instanceof Object) {
        this.log = (ref = opts.log) != null ? ref.child({
          "class": this.constructor.name
        }) : void 0;
        filename = opts.path;
      } else {
        filename = opts;
      }
      if (this.log == null) {
        this.log = new bunyan({
          name: this.constructor.name
        });
      }
      this.running = true;
      this.entries = {};
      if (filename) {
        this.db = require('dirty')("" + filename);
        this.db.on('load', (function(_this) {
          return function() {
            var err;
            _this.log.info({
              method: 'load',
              path: filename
            }, "loading a registry from a persistent db");
            try {
              _this.db.forEach(function(key, val) {
                _this.log.debug({
                  method: 'load',
                  key: key
                }, "found a record, issuing load event handler");
                if (val != null) {
                  return _this.emit('load', key, val);
                }
              });
            } catch (_error) {
              err = _error;
              _this.log.error(err, "issue during processing the db file at " + filename);
            }
            return _this.emit('ready');
          };
        })(this));
        this.db._writeStream.on('error', (function(_this) {
          return function(err) {
            return _this.log.error(err, 'failed to open file for writing');
          };
        })(this));
      } else {
        process.nextTick((function(_this) {
          return function() {
            return _this.emit('ready');
          };
        })(this));
      }
    }

    StormRegistry.prototype.add = function(key, entry) {
      var data, err;
      if (entry == null) {
        return;
      }
      if (this.get(key)) {
        this.remove(key);
      }
      if (key == null) {
        key = uuid.v4();
      }
      if (entry.id == null) {
        entry.id = key;
      }
      if (entry.saved == null) {
        entry.saved = false;
      }
      this.log.debug({
        method: 'add',
        key: key
      }, "adding a new entry");
      if ((this.db != null) && !entry.saved) {
        data = (function() {
          switch (false) {
            case !(entry instanceof StormRegistryData):
              return entry.serialize({
                tag: true
              });
            default:
              return entry;
          }
        })();
        this.log.debug({
          method: 'add',
          key: key
        }, "saving entry into persistent db");
        try {
          this.db.set(key, data);
          entry.saved = true;
        } catch (_error) {
          err = _error;
          this.log.error({
            error: err,
            data: data
          }, "failed to save the provided data record");
        }
      }
      this.entries[key] = entry;
      this.emit('added', entry);
      return entry;
    };

    StormRegistry.prototype.get = function(key) {
      if (!((key != null) && this.entries.hasOwnProperty(key))) {
        return;
      }
      return this.entries[key];
    };

    StormRegistry.prototype.remove = function(key) {
      var entry;
      if (key == null) {
        return;
      }
      this.log.debug({
        method: 'remove',
        key: key
      }, "removing an entry");
      entry = this.entries[key];
      delete this.entries[key];
      if (entry != null) {
        this.emit('removed', entry);
      }
      if ((this.db != null) && (entry != null) && entry.saved) {
        return this.db.rm(key);
      }
    };

    StormRegistry.prototype.update = function(key, entry, suppress) {
      var data;
      if (!((key != null) && (entry != null))) {
        return;
      }
      this.log.debug({
        method: 'update',
        key: key
      }, "updating an entry");
      if ((this.db != null) && (!entry.saved || entry.changed)) {
        data = (function() {
          switch (false) {
            case !(entry instanceof StormRegistryData):
              return entry.serialize({
                tag: true
              });
            default:
              return entry;
          }
        })();
        this.db.set(key, data);
        this.log.debug({
          method: 'update',
          key: key,
          data: data
        }, "saved an entry into persistent db");
        entry.saved = true;
      }
      this.entries[key] = entry;
      if (suppress !== true) {
        this.emit('updated', entry);
      }
      return entry;
    };

    StormRegistry.prototype.list = function() {
      var key;
      return ((function() {
        var results;
        results = [];
        for (key in this.entries) {
          results.push(this.get(key));
        }
        return results;
      }).call(this)).filter(function(x) {
        return x != null;
      });
    };

    StormRegistry.prototype.checksum = function() {
      var crypto, entry, key, md5, ref;
      crypto = require('crypto');
      md5 = crypto.createHash("md5");
      ref = this.entries;
      for (key in ref) {
        entry = ref[key];
        md5.update(key);
      }
      return md5.digest("hex");
    };

    StormRegistry.prototype.expires = function(interval, validity) {
      var entry, fn, key, ref;
      if (validity == null) {
        validity = 60 * 60;
      }
      ref = this.entries;
      fn = function(entry) {
        return entry.validity != null ? entry.validity : entry.validity = validity;
      };
      for (key in ref) {
        entry = ref[key];
        fn(entry);
      }
      return async.whilst((function(_this) {
        return function() {
          return _this.running;
        };
      })(this), (function(_this) {
        return function(repeat) {
          var fn1, ref1;
          ref1 = _this.entries;
          fn1 = function(key, entry) {
            _this.log.debug(key + " has validity=" + entry.validity);
            _this.entries[key].validity -= interval / 1000;
            if (!(_this.entries[key].validity > 1)) {
              _this.remove(key);
              _this.log.info({
                method: 'expires',
                key: key
              }, "entry has expired and removed from registry");
              return _this.emit("expired", entry);
            }
          };
          for (key in ref1) {
            entry = ref1[key];
            if (entry == null) {
              _this.remove(key);
              continue;
            }
            fn1(key, entry);
          }
          return setTimeout(repeat, interval);
        };
      })(this), (function(_this) {
        return function(err) {
          return _this.log.warn({
            method: 'expires'
          }, "registry stopped running, validity checker stopping...");
        };
      })(this));
    };

    return StormRegistry;

  })(EventEmitter);

  module.exports = StormRegistry;

  module.exports.Data = StormRegistryData;

}).call(this);
